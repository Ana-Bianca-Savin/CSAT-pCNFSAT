Am ales sa implementez tema in C. Astfel fiecare nod al arborelui contine:
    - indice -> numarul ce ii corespunde
    - tip -> 1 daca nodul este input sau 2 daca nodul este poarta
    - tipPoarta -> -1 daca nodul este input, 1 daca poarta este AND, 2 daca poarta este OR, 3 daca poarta este NOT
    - parinte -> nodul parinte al nodului curent, este NULL pt radacina
    - fii -> un vector ce retine nodurile copil, este initializat la inceput cu spatiu pentru 60 de fii

In main, prima data sunt deschise fisierele de citire si scriere. Se citesc numarul de input-uri si indicele portii de iesire. Numarul de porti este egal cu acest indice minus numarul de input-uri.
Initializam o matrice de int ce va retine informatia primita in fisierul de intrare despre porti si variabile. Parcurgem fisierul, citind cate o linie pe rand. La fiecare pas o linie din matrice retine, pe pozitia 0 tipul portii (1 pt AND, 2 pt OR, 3 pt NOT), pe pozitia 1 indicele portii, iar pe restul pozitiilor variabilele sau portiile ce intra in poarta curenta.
Este apelata o functia recursiva ce primeste ca parametru matricea descrisa anterior, care construieste arborele. La fiecare pas, se initializeaza indicele mai intai. Daca acesta este mai mic decat numarul de input-uri, acesta este un input si este suficient sa initializat tip si tipPoarta, deoarece nu exista copii. Daca nodul curent este o poarta, se cauta dupa indice in matrice, acesta aflandu-se pe coaloana 1. Dupa gasire, sunt parcursi fiii portii din matrice, fiecare fiind alocat si adaugat in vectorul de copii mai intai.
In continuare, este alocata o functie care initializeaza parintii nodurilor, printr-o simpla parcurgere in adancime.

Pentru a aduce arborele curent la ceva din care poate reiese un CNFSAT, trebuie sa executam o serie de transformari asupra lui.
Mai intai, trebuie sa distribuim portiile NOT peste copii. Astfel, se apeleaza o functie recursiva care retine intr-un parametru daca nodul curent se afla sub negatie. Daca acest lucru este adevarat, atunci portiile AND devin OR, cele OR devin AND, iar input-urile, primesc valoarea lor cu semn schimbat. La fiecare pas, se verifica daca poarta curenta este NOT, iar in caz afirmativ, valoarea parametrului sub negatie se schimba, iar poarta e stearsa.

Urmatorul pas este sa eliminam portiile inutile, adica, daca o poarta AND are un parinte AND, parintele ar trebui sa adopte copiii copilului, iar acesta sa fie eliminat; la fel si pentru OR. Astfel, se foloseste o functie recursiva ce accepta ca parametru tipul de porti care se doreste a fi sters (1 pt AND, 2 pt OR). La fiecare pas, daca poarta curenta si parintele ei au acelasi tip care coincide cu tipul din parametru, se verifica daca parintele are loc pentru copiii copilului si se aloca mai mult spatiu daca este nevoie; este cautat copilul in vectorul de fii, apoi este sters, iar, la final, se adauga toti copiii copilului sters. Aceasta functie este apelata de doua ori in main, pentru a sterge portiile de ambele feluri ramase (AND si OR).

Ultima etapa consta in distribuirea portiilor OR peste cele AND, acolo unde este nevoie. De data aceasta structura functiei recursive va fi: conditie de iesire, apel pentru toti fiii, prelucrare nod curent. Facand acest lucru, cel mai rau caz in care trebuie sa distribuim o poarta OR peste fii, nu poata depasi secventa OR - AND - OR (daca dupa OR, ar mai exista un AND, acest caz ar fi fost deja rezolvat dintr-un apelul anterior al functiei in momentul in care ne aflam la pasul curent). Intr-un pas, se verifica daca poarta curenta este OR si daca are minim un copil AND. Daca aceste lucruri sunt indeplinite, poarta trebuie distribuita peste copii. Alocam o matrice care va retine pe fiecare linie combinatii de input-uri ce reies in urma distrubuirii. Pe linia 0, modelam perechea curenta, iar daca este in regula, va fi adaugata pe prima linie libera. Daca poarta OR curenta are si copii input-uri, acestia vor fi prezenti in fiecare pereche, deci sunt adaugati pe linia 0 si stersi din vectorul de fii. Dupa aceasta prelucrare, raman doua cazuri de tratat. Daca numarul de fii ramasi este mai mare sau egal cu doi si daca ramane doar un fiu.
Pentru primul caz, se foloseste o functie recursiva, ce trateaza toate cazurile posibila de combinatii. Ea primeste ca parametru capul arborelui curent (adica poarta OR ce trebuie distribuita) si indicele fiului din ea in care ne aflam la un anumit apel. Astfel verificam daca perechea curenta este buna, atunci cand s-au adaugat noduri din fiecare fiul al capului, adica indicele + 1 = numarul de fii. La fiecare pas, prima data se face aceasta verificare. Apoi, daca poarta este OR (conditie ce va fi mereu adevarata la primul apel), se parcurg fiii. Acestia pot fi doar input-uri sau porti AND (am eliminat dublurile inainte). Daca este un input, el este adaugat pe ultima pozitie in perechea curenta (adica pe linia 0 in matricea de perechi), se executa un apel pentru urmatorul fiu al capului, iar apoi se scoate din pereche input-ul (mereu va fi pe ultima pozitie). Daca fiul este o poarta AND, trebuie parcursi si fiii acesteia (care pot fi doar input-uri sau porti OR). Daca fiul portii AND este input, se repeta pasii de mai sus. Daca este OR, este garantat ca fiii acesteia sunt doar input-uri (daca ar fi fost o poarta AND, s-ar mai fi apelata aceasta functia inainte si problema ar fi fost rezolvata deja). Atunci, sunt adaugati la perechea curenta toti copiii portii OR, se face apelul pentru urmatorul fiu al copului si se scot fiii portii OR din pereche. Astfel sunt construite perechiile.
Pentru al doilea caz, conditia de verificare indicele + 1 = numarul de fii nu mai este valabila, pentru ca ea ar fi adevarata din prima. Asa ca, se apeleaza o alta functie, similara cu cea descrisa in primul caz, dar in loc de apeluri recursive, se verifica daca perechea curenta este buna.
Dupa revenirea din oricare dintre cele doua cazuri descrise avem matricea perechi construita. Astfel, stergem fiii vechi ai portii OR si o transformam in poarta de tip AND. Pentru fiecare pereche, creeam o poarta OR parinte pentru copiii de pe fiecare linie, si o adaugam in vectorul de copii ai vechii porti OR. Deoarece ea este AND acum, este posibil ca si parintele sa fie tot AND, asa ca apelam functia de eliminare a portiilor inutile AND.

La final, se face afisarea sunt formatul dorit. Numarul de input-uri e acelasi ca cel citit din fisier. Numarul de clauze este 1 daca poarta parinte este OR sau un input si este numarul de fii (porti OR si input-uri) de pe nivelul 2, daca radacina este AND. Pentru ultimul caz, clauzele se afiseaza prin parcurgerea copiilor si afisarea input-urilor si a fiilor portiilor OR ca o clauza.